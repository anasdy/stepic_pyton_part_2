# -*- coding: utf-8 -*-
"""
Created on Wed Nov 13 11:37:51 2019

@author: niili

Реализовать класс multifilter, который будет выполнять ту же функцию, что и 
стандартный класс filter, но будет использовать не одну функцию, а несколько.

Решение о допуске элемента принимается на основании того, сколько функций 
допускают этот элемент, и сколько не допускают. Обозначим эти количества за 
pos и neg.

Решающая функция – это функция, которая принимает два аргумента – количества 
pos и neg, и возвращает True, если элемент допущен, и False иначе.

Рассмотрим процесс допуска подробнее на следующем примере.
a = [1, 2, 3]
f2(x) = x % 2 == 0 # возвращает True, если x делится на 2
f3(x) = x % 3 == 0
judge_any(pos, neg) = pos >= 1 # возвращает True, если хотя бы одна функция 
допускает элемент.

Возьмем первый элемент x = 1.
f2(x) равно False, т. е. функция f2 не допускает элемент x.
f3(x) также равно False, т. е. функция f3 также не допускает элемент x.
В этом случае pos = 0, так как ни одна функция не допускает x, и соответственно neg = 2.
judge_any(0, 2) равно False, значит мы не допускаем элемент x = 1.

Возьмем второй элемент x = 2.
f2(x) равно True
f3(x) равно False
pos = 1, neg = 1
judge_any(1, 1) равно True, значит мы допускаем элемент x = 2.

Аналогично для третьего элемента x = 3.

Таким образом, получили последовательность допущенных элементов [2, 3].


Класс должен обладать следующей структурой:

class multifilter:
    def judge_half(pos, neg):
        # допускает элемент, если его допускает хотя бы половина фукнций (pos >= neg)

    def judge_any(pos, neg):
        # допускает элемент, если его допускает хотя бы одна функция (pos >= 1)

    def judge_all(pos, neg):
        # допускает элемент, если его допускают все функции (neg == 0)

    def __init__(self, iterable, *funcs, judge=judge_any):
        # iterable - исходная последовательность
        # funcs - допускающие функции
        # judge - решающая функция

    def __iter__(self):
        # возвращает итератор по результирующей последовательности
        
        
        
        
        
Я вижу 2 варианта решения задачи.
1.  Добавить результирующую последовательность как элемент класса. В функции 
    init для каждого элемента принимать решение о допуске, если да - сохранять 
    в результирующей последовательности. Но, в таком варианте не совсем логично
    использование функции iter. Так что, видимо, подразумевался второй вариант 
    решения.
2.  В класс в качестве элементов добавляем все, что передается в функцию init.
    Метод iter - генератор, при каждом вызове которого, он идет по переданной 
    последовательности, пока не найдет очередной допускаемый элемент, указатель
    на который и возвращает.

Реализовывать буду второй варинт. 
(Хотя первый привлекает меня меньшим использованием памяти)

"""

class multifilter:
    def judge_half(pos, neg):
        # допускает элемент, если его допускает хотя бы половина фукнций (pos >= neg)
        if pos >= neg:
            return True
        else:
            return False

    def judge_any(pos, neg):
        # допускает элемент, если его допускает хотя бы одна функция (pos >= 1)
        if pos >= 1:
            return True
        else:
            return False

    def judge_all(pos, neg):
        # допускает элемент, если его допускают все функции (neg == 0)
        if neg == 0:
            return True
        else:
            return False

    def __init__(self, iterable, *funcs, judge=judge_any):
        # iterable - исходная последовательность
        # funcs - допускающие функции
        # judge - решающая функция
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge

    def __iter__(self):
        # возвращает итератор по результирующей последовательности
        
        # идем по переданной последовательности
        for i in self.iterable:
            # для каждого её элемента считаем количество допустивших функций
            pos = 0
            neg = 0
            for func in self.funcs:
                if func(i):
                    pos += 1
                else:
                    neg += 1
            # применяем допускающую функцию
            if self.judge(pos, neg):
                # если допуск есть - возвращаем элемент как следующий
                yield i
            else:
                # иначе переходим к следующему элементу
                continue