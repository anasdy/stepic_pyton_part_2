# -*- coding: utf-8 -*-
"""
Created on Thu Oct 17 00:59:41 2019

@author: niili

Дано описание наследования классов исключений в следующем формате.
<имя исключения 1> : <имя исключения 2> <имя исключения 3> ... 
                                                            <имя исключения k>
Это означает, что исключение 1 наследуется от исключения 2, исключения 3, 
и т. д.

В первой строке входных данных содержится целое число n - число классов 
исключений.

В следующих n строках содержится описание наследования классов. В i-й строке 
указано от каких классов наследуется i-й класс. Класс может ни от кого не 
наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или 
косвенно), что класс не наследуется явно от одного класса более одного раза.

В следующей строке содержится число m - количество обрабатываемых исключений.
Следующие m строк содержат имена исключений в том порядке, в каком они были 
написаны в коде.
Гарантируется, что никакое исключение не обрабатывается дважды.

Вывести в отдельной строке имя каждого исключения, обработку которого можно 
удалить из кода, не изменив при этом поведение программы. Имена следует 
выводить в том же порядке, в котором они идут во входных данных.


Типы исключений не созданы.
Создавать классы исключений также не требуется


Структура исключений хранится в словаре, где ключ - имя исключения, а 
значение - список предков.

Прошрама читает структуру исключений, затем в цикле читает список 
использованных исключений и сразу проверяет использовались ли ранее его предки.
"""
class exc_tree_clss:
    
    def __init__(self):
        # словарь для структуры исключений
        # ключ - имя исключения, значение - список предков
        self.exc_dict = dict()
        
        
    #--------------------------------------------------------------------------
    # Функуция определения вводилось ли уже исключение или его предок.
   
    # Аргументы функции:
    # exc_1 - Имя класса 1, предполагаемого предка, тип str
    # exc_2 - Имя класса 2, предполагаемого потомкаб тип str
    
    # Возвращаемое значение
    # True - если exc_1 является предком exc_2 .
    # False - в противном случае
    #---------------------------------------------------------
    def f_exc_parents_seach(self, exc, exc_list):
        # Если оно уже есть в списке, значит писать не нужно
        if exc in exc_list:
            return True
        else:
            # если кто-то из предков есть в списке
            for exc_i in self.exc_dict[exc]:
                if self.f_exc_parents_seach(exc_i, exc_list):
                    # то писать тоже не нужно
                    return True
                else:
                    continue
        return False




#------------------------------------------------------------------------------

# читаем n
try:
    n_exception = int(input())
except ValueError:
    print("Value Error. Please try again!")
    n_exception = int(input())
#------------------------------------------------

except_clss = exc_tree_clss()
for i in range(n_exception):
    # читаем строку
    except_name = input()
    # если в ней есть :, то исключение унаследовано от других исключений
    if ':' in  except_name:
        # разделяем имя исключения и его предков
        except_name, except_parents = except_name.split(" :")
        # формируем список предков
        except_parents = except_parents.split()
    # если : не было
    else:
        # то список предков пуст
        except_parents = []
    # добавляем исключение в словарь
    except_clss.exc_dict[except_name] = except_parents

#------------------------------------------------    
# читаем количество использованных исключений
try:
    m_exception = int(input())
except ValueError:
    print("Value Error. Please try again!")
    m_exception = int(input()) 

#------------------------------------------------
# список использованных исключений
exception_list = []
for i in range(m_exception):
    # читаем исключение
    exc = input()
    if except_clss.f_exc_parents_seach(exc, exception_list):
        print(exc)

    exception_list.append(exc)

